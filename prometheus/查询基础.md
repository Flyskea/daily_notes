# Prometheus 查询语言（PromQL）

Prometheus提供了一个功能性查询语言，称为PromQL（Prometheus查询语言），允许用户实时选择和聚合时间序列数据。表达式的结果可以显示为图形，也可以在Prometheus的表达式浏览器中以表格数据查看，还可以通过HTTP API被外部系统使用。

# 示例

本文档旨在作为参考。对于学习，可以从以下几个示例开始。

# 表达式语言数据类型

在PromQL中，一个表达式或子表达式可以计算出以下四种数据类型之一：

- **瞬时向量（Instant vector）**：包含每个时间序列的单个样本，所有样本共享相同的时间戳。
- **区间向量（Range vector）**：包含每个时间序列的一段时间内的数据点区间。
- **标量（Scalar）**：简单的数值浮点值。
- **字符串（String）**：简单的字符串值；当前未使用。

根据用例（例如绘图与显示表达式的输出），只有其中一些数据类型作为用户指定表达式的结果是合法的。例如，返回瞬时向量的表达式是唯一可以直接绘制图形的类型。

关于实验性原生直方图的注意事项:

- 必须通过功能标志启用导入原生直方图。
- 一旦原生直方图被导入到TSDB中（即使在再次禁用功能标志之后），瞬时向量和区间向量现在可能包含不是简单浮点数（浮点样本）而是完整直方图（直方图样本）的样本。向量中可以包含混合的浮点样本和直方图样本。

# 字面量

## 字符串字面量

字符串可以使用单引号、双引号或反引号指定为文字。

PromQL遵循与Go相同的转义规则。在单引号或双引号中，反斜杠开始一个转义序列，后面可以跟随a、b、f、n、r、t、v或\。可以使用八进制（\nnn）或十六进制（\xnn、\unnnn和\Unnnnnnnn）提供特定字符。

反引号内不进行转义处理。与Go不同，Prometheus不会丢弃反引号内的换行符。

示例：

- `"this is a string"`
- `'these are unescaped: \n \\ \t'`
- `` `these are not unescaped: \n ' " \t` ``

## 浮点数字面量  

标量浮点值可以写为整数或浮点数格式（仅包含空格以便更好地阅读）：

```
[-+]?(
      [0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?
    | 0[xX][0-9a-fA-F]+
    | [nN][aA][nN]
    | [iI][nN][fF]
)
```

示例：

```
23
-2.43
3.4e-9
0x8f
-Inf
NaN
```

# 时间序列选择器

## 瞬时向量选择器

瞬时向量选择器允许选择一组时间序列，并为给定时间戳（瞬时）选择每个时间序列的单个样本值：在最简单的形式下，只需指定一个指标名称。这将导致包含所有具有此指标名称的时间序列的瞬时向量。

此示例选择具有http_requests_total指标名称的所有时间序列：

```PromQL
http_requests_total
```

还可以通过在花括号（{}）中附加逗号分隔的标签匹配器列表来进一步过滤这些时间序列。

此示例仅选择具有http_requests_total指标名称的那些时间序列，同时其job标签设置为prometheus且group标签设置为canary：

```PromQL
http_requests_total{job="prometheus",group="canary"}
```

还可以对标签值进行否定匹配，或使用正则表达式匹配标签值。以下标签匹配操作符可用：

- `=`：选择标签与提供的字符串完全相等的时间序列。
- `!=`：选择标签与提供的字符串不相等的时间序列。
- `=~`：选择标签与提供的正则表达式匹配的时间序列。
- `!~`：选择标签与提供的正则表达式不匹配的时间序列。

正则表达式匹配完全锚定。`env=~"foo"`的匹配被视为`env=~"^foo$"`。

例如，这将选择所有staging、testing和development环境以及HTTP方法不为GET的http_requests_total时间序列：

sqlCopy code

```PromQL
http_requests_total{environment=~"staging|testing|development",method!="GET"}
```

匹配空标签值的标签匹配器也会选择所有未设置该特定标签的时间序列。可以对同一标签名设置多个匹配器。

向量选择器必须指定名称，或至少一个不匹配空字符串的标签匹配器。以下表达式是非法的：

```
{job=~".*"} # Bad!
```

相反，以下表达式是有效的，因为它们都有一个不匹配空标签值的选择器。

```
{job=~".+"}              # Good!
{job=~".*",method="get"} # Good!
```

标签匹配器也可以应用于指标名称，通过针对内部__name__标签进行匹配。例如，表达式http_requests_total等效于{**name**="http_requests_total"}。除 `=` (`!=`, `=~`, `!~`)之外的匹配器也可以使用。以下表达式选择所有名称以job:开头的指标：

```
{__name__=~"job:.*"}
```

指标名称不能是关键字bool、on、ignoring、group_left和group_right。以下表达式是非法的：

```
on{} # Bad!
```
解决此限制的方法是使用__name__标签：

```
{__name__="on"} # Good!
```

Prometheus 中的所有正则表达式均使用 RE2语法。

## 区间向量选择器

区间向量选择器的工作方式类似于瞬时向量选择器，只是它们选择从当前时刻向前一段时间的样本区间。在语法上，向量选择器的末尾加上一个时间持续时间，用方括号（[]）括起来，以指定为每个结果区间向量元素获取值的时间区间。区间是一个闭区间，即与区间边界时间戳恰好匹配的样本仍然包含在选择中。

在这个示例中，我们选择在过去5分钟内所有记录的http_requests_total指标名称为prometheus的所有时间序列的值：

```
http_requests_total{job="prometheus"}[5m]
```

持续时间

持续时间以数字开头，紧接着是以下单位之一：

- `ms` - 毫秒
- `s` - 秒
- `m` - 分钟
- `h` - 小时
- `d` - 天 - 假设一天始终有24小时
- `w` - 周 - 假设一周始终有7天
- `y` - 年 - 假设一年始终有365天

时间持续时间可以组合，通过连接在一起。单位必须按照从最长到最短的顺序排列。每个单位在时间持续时间中只能出现一次。

以下是一些有效的时间持续时间的示例：

- `5h`
- `1h30m`
- `5m`
- `10s`

### 偏移修饰符

偏移修饰符允许在查询中为单个瞬时和区间向量更改时间偏移。

例如，以下表达式返回相对于当前查询评估时间5分钟之前的http_requests_total值：

```
http_requests_total offset 5m
```

注意，偏移修饰符必须始终紧随选择器之后，即以下是正确的：

```
sum(http_requests_total{method="GET"} offset 5m) // GOOD.
```

而以下是不正确的：

```
sum(http_requests_total{method="GET"}) offset 5m // INVALID.
```

对于区间向量也同样适用。以下表达式返回http_requests_total一周前的5分钟速率：

```
rate(http_requests_total[5m] offset 1w)
```

对于向前时间的比较，可以指定一个负的偏移：

```
rate(http_requests_total[5m] offset -1w)
```

注意，这允许查询在其评估时间之前查看数据。

### @ 修饰符

@ 修饰符允许在查询中为单个瞬时和区间向量更改评估时间。提供给 @ 修饰符的时间是Unix时间戳，并用浮点文字描述。

例如，以下表达式返回http_requests_total在2021-01-04T07:40:00+00:00时的值：

```
http_requests_total @ 1609746000
```
注意，@ 修饰符必须始终紧随选择器之后，即以下是正确的：

```
sum(http_requests_total{method="GET"} @ 1609746000) // GOOD.
```

而以下是不正确的：

```
sum(http_requests_total{method="GET"}) @ 1609746000 // INVALID.
```

对于区间向量也同样适用。以下表达式返回http_requests_total在2021-01-04T07:40:00+00:00时的5分钟速率：

```
sum(http_requests_total{method="GET"}) @ 1609746000 // INVALID.
```

@ 修饰符支持所有上述浮点文字的表示形式，但受int64限制。它也可以与偏移修饰符一起使用，其中偏移相对于 @ 修饰符的时间应用，而不考虑哪个修饰符先写。以下两个查询将产生相同的结果：

```
# offset after @
http_requests_total @ 1609746000 offset 5m
# offset before @
http_requests_total offset 5m @ 1609746000
```

此外，start()和end()也可以用作 @ 修饰符的值，作为特殊值。

对于区间查询，它们分别解析为区间查询的起始和结束，并对所有步骤保持不变。

对于瞬时查询，start()和end()都解析为评估时间。

```
http_requests_total @ start()
rate(http_requests_total[5m] @ end())
```

注意，@ 修饰符允许查询在其评估时间之前查看数据。

# 子查询

子查询允许您在给定区间和分辨率上运行瞬时查询。子查询的结果是一个区间向量。

语法：`<instant_query> '[' <range> ':' [<resolution>] ']' [ @ <float_literal> ] [ offset <duration> ]`

`<resolution>`是可选的。默认为全局评估间隔。


# 注释

PromQL支持以#开头的行注释。示例：

bashCopy code

```
# This is a comment
```

# 要注意的事项

## 过期数据

运行查询时，选择采样数据的时间戳与实际的现有时间序列数据无关。这主要是为了支持聚合（sum、avg等）的情况，其中多个聚合时间序列在时间上并不完全对齐。由于它们是独立的，因此Prometheus需要为每个相关时间序列在这些时间戳上分配一个值。它通过简单地在该时间戳之前选择最新的样本来实现。

如果目标抓取或规则评估不再返回之前存在的时间序列的样本，那么该时间序列将被标记为过期。如果删除目标，则其先前返回的时间序列将很快被标记为过期。

如果在采样时间戳后的查询评估时间之前，时间序列被标记为过期，则该时间序列不会返回值。如果随后为该时间序列插入新样本，则它们将正常返回。

如果在采样时间戳之前（默认情况下是5分钟）找不到样本，则在这一时间点上不会返回该时间序列的值。这实际上意味着时间序列在其最新收集的样本的时间早于5分钟或被标记为过期后，会从图形中“消失”。

对于时间戳包含在其抓取中的时间序列，不会标记为过期。在这种情况下，仅应用5分钟阈值。

## 避免慢查询和过载

如果查询需要处理大量的数据，将其绘制为图形可能会超时或导致服务器或浏览器负载过重。因此，在构建对未知数据的查询时，始终从Prometheus的表达式浏览器的表格视图开始构建查询，直到结果集看起来合理（最多数百个时间序列）。仅当您已经对数据进行足够的筛选或聚合后，切换到图形模式。如果表达式在临时绘制时仍然花费太长时间，可以通过预先记录一个录制规则来解决。

这在Prometheus的查询语言中尤其重要，其中类似api_http_requests_total的裸指标名称选择器可能会扩展到具有不同标签的数千个时间序列。还请记住，对许多时间序列进行聚合的表达式将在服务器上产生负载，即使输出只有少数时间序列。这类似于在关系数据库中对一列的所有值求和会很慢，即使输出值只有一个数。