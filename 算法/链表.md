# 
# 1. 哨兵模式

哨兵模式主要应用在以下题型:
- 需要保留参数 head 头节点的指针并作为返回值返回，例如 “删除链表中的节点” 类型问题
- 无法提前确认返回值具体是哪个节点，例如 “合并链表” 类型问题，“反转链表” 类型问题

### 代码模板

使用哨兵模式时，要记住两个必需的核心变量:
1. 哨兵节点：作为基准保存返回值，其 Next 指向具体的返回值，一般命名为 `dummy`, 当然也有人称之为 `哑巴节点`
2. 扫描节点：从链表头节点开始向后扫描，直到尾节点或符合条件的节点，作用简单来说就是 `游标指针`，一般命名为 `cur`

下面是一个典型的使用哨兵模式解题的代码模板:

```go
func Solution(head *ListNode) *ListNode {
 // 哨兵节点指向 头节点
 dummy := &ListNode{Next: head}

 // 游标节点   
 cur := dummy

 for cur.Next != nil {
   // 执行某些解题逻辑代码

   ...

   // 更新游标指针
   // 虽然游标指针一直在变化，但是哨兵节点指针的指向没有发生变化
   cur = cur.Next
 }

 // 返回哨兵节点指向的 头节点
 return dummy.Next
}
```

## [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/description/)

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

![](../picture/a28eb5d141b809a0f0febf52ca6bea66_MD5.jpeg)

> **输入：** l1 = [1,2,4], l2 = [1,3,4]
> **输出：** [1,1,2,3,4,4]

解题思路：同时遍历链表 1 和链表 2，将两个链表中的当前较小值插入到合并到后的链表中并套用模板

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
	dummy := &ListNode{}
	p := dummy
	for l1 != nil && l2 != nil {
		if l1.Val < l2.Val {
			p.Next = l1
			l1 = l1.Next
		} else {
			p.Next = l2
			l2 = l2.Next
		}
		p = p.Next
	}
	if l1 != nil {
		p.Next = l1
	}
	if l2 != nil {
		p.Next = l2
	}
	return dummy.Next
}
```


## [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/description/)

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

![示例1](../picture/3c1f3c4ae9a023b7fe725d6aa4e7bf1a_MD5.jpeg)

>**输入：** l1 = [2,4,3], l2 = [5,6,4]
> **输出：** [7,0,8]
> **解释：** 342 + 465 = 807.

解题思路：套入模板，同时遍历链表 1 和链表 2，取出两个链表的当前节点的值以及进位进行相加，并将结果放入合并后的链表的下一个节点。同时保存进位

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
	// 哨兵节点
	dummy := &ListNode{}
	cur := dummy
	carry := 0 // 进位

	for l1 != nil || l2 != nil || carry != 0 {
		if l1 != nil {
			carry += l1.Val
			l1 = l1.Next
		}
		if l2 != nil {
			carry += l2.Val
			l2 = l2.Next
		}
		// 当计算出来的新节点放到当前节点后面
		cur.Next = &ListNode{Val: carry % 10}
		//保存进位
		carry /= 10
		// 更新当前节点
		cur = cur.Next
	}

	return dummy.Next
}
```


## [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

![](../picture/ad31a62ebfc4db2610c2a254b22444b0_MD5.jpeg)

> **输入：** head = [1,2,3,4]
> **输出：** [2,1,4,3]

解题思路：使用指针遍历链表，当游标指针的下一个节点和下下一个节点同时不为 nil 时，交换两者

```go
func swapPairs(head *ListNode) *ListNode {
	// 哨兵节点
	dummy := &ListNode{Next: head}
	cur := dummy
	
	for cur.Next != nil && cur.Next.Next != nil {
		p1, p2 := cur.Next, cur.Next.Next
		// 交换 p1 和 p2 节点
		cur.Next = p2
		p1.Next = p2.Next
		p2.Next = p1
		// 将 cur 移动到下一组待交换的节点的前一个节点处
		cur = p1
	}

	return dummy.Next
}
```

## [86. 分隔链表](https://leetcode.cn/problems/partition-list/description/)

给你一个链表的头节点 `head` 和一个特定值 `x` ，请你对链表进行分隔，使得所有 **小于** `x` 的节点都出现在 **大于或等于** `x` 的节点之前。

你应当 **保留** 两个分区中每个节点的初始相对位置。


![示例1](../picture/14d9d67c5cadc2a27753e00031f76704_MD5.jpeg)

> **输入：** head = [1,4,3,2,5,2], x = 3
> **输出** ：[1,2,2,4,3,5]

解题思路：
- 两个哨兵节点: 将小于 X 的所有节点单独形成一个链表 less, 将大于等于 X 的所有节点单独形成一个链表 greater, 声明两个哨兵节点分别指向 less 链表的头节点和 greater 链表的头节点
- **填充具体的解题逻辑**：使用游标指针遍历链表，将小于 X 的节点插入到链表 less 末尾, 将大于等于 X 的节点插入到链表 large greater，遍历完成之后，连接 less 链表和 greater 链表，并切断 large 链表的尾指针指向，防止链表形成环。

```go
func partition(head *ListNode, x int) *ListNode {
	LessDummy := &ListNode{}
	GreaterDummy := &ListNode{}
	cur := head
	p1, p2 := LessDummy, GreaterDummy
	for cur != nil {
		if cur.Val < x {
			p1.Next = cur
			p1 = p1.Next
		} else {
			p2.Next = cur
			p2 = p2.Next
		}
		cur = cur.Next
	}
	// 切断 greater 链表的尾指针
    // 例如源链表为 1 -> 4 -> 3 -> 2 -> 5 -> 2, X = 3
    // 那么在分割完成后
    // less 链表为 1 -> 2 -> 2 -> 5 ...
    // greater 链表为 4 -> 3 -> 5 -> 2 ...
    // 这时就需要将 greater 链表末尾指针给切断，否则就形成了 “环形链表”
	p2.Next = nil

	// 将 less 链表连接到 greater 链表
	p1.Next = GreaterDummy.Next
	return LessDummy.Next
}
```

# 2. 快慢指针

快慢指针是使用两个指针来遍历链表，快指针走的快 (例如每次扫描两个及以上节点)，慢指针走的慢 (例如每次扫描一个节点)，严格意义上来说，**“快慢指针” 属于 “双指针” 的解题类型范畴**，之所以在这篇关于链表类的文章中单独拎出来，主要有两点：

1. 链表的节点就是由指针连接起来的，天然适用于快慢指针来遍历，比如我们可以使用 **快慢指针来简洁实现 “找到链表的中间节点”**
2. 链表类型的某些问题，使用快慢指针是最简洁优雅的方案，例如经典的 “判断链表中是否存在环问题”

## 代码模板

```go
func Solution(head *ListNode) bool {
    // 通用边界检查
    if head == nil {
        return false
    }

    // 初始化快、慢两个指针
    slow, fast := head, head.Next
    // 主要这里的边界检查
    // 因为快指针每次走两步，需要需要检测两步之内的节点是否为 nil
    // 慢指针无需执行边界检查
    // 因为只要快指针不为 nil, 慢指针肯定也不会为 nil
    for fast != nil && fast.Next != nil {
        // 执行某些解题逻辑代码

        ...

        // 快指针每次走 2 步
        fast = fast.Next.Next
        // 慢指针每次走 1 步
        slow = slow.Next
    }

    return false
}
```

##  [141. 环形链表 ](https://leetcode.cn/problems/linked-list-cycle/)

给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。

_如果链表中存在环_ ，则返回 `true` 。否则，返回 `false` 。

![示例1](../picture/20bdeb1e3af738286274a18bdc329a4b_MD5.jpeg)

> **输入：** head = [3,2,0,-4], pos = 1
> **输出：** true
> **解释：** 链表中有一个环，其尾部连接到第二个节点。

解题思路：
- 定义快慢指针，
- 在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。

```go
func hasCycle(head *ListNode) bool {
	if head == nil {
		return false
	}

	// 快指针先走，避免提前判断快慢指针重合
	slow, fast := head, head.Next
	for fast != nil && fast.Next != nil {
		if slow == fast {
			return true
		}
		fast = fast.Next.Next
		slow = slow.Next
	}

	return false
}

```