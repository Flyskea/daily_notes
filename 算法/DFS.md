DFS (深度优先搜索) 是一种用于遍历树或图数据结构的算法，其基本思想是从起始节点 (通常是根节点) 出发，沿着路径尽可能进行深度搜索，直到到达最深的节点，然后再回溯到之前的节点继续 (递归) 深度搜索其他路径，直到搜索完所有可能的路径，算法结束。
# 算法基本步骤

1. 从起始节点 (根节点) 开始遍历，将其标记为已访问
    
2. 单次遍历过程中，对于 “当前节点”，依次访问其所有相邻节点
    
3. 对于每个相邻节点，如果未被访问过，递归调用 DFS
    
4. 当所有相邻节点都被访问过或当前节点没有相邻节点时，回溯到上一级节点，继续搜索其他路径
# [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/description/)

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

> **输入**：grid = [
>   ["1","1","1","1","0"],
>   ["1","1","0","1","0"],
>   ["1","1","0","0","0"],
>   ["0","0","0","0","0"]
> ]
> **输出**：1

解题思路：

1. 递归结束条件: 当前坐标超出边界 (二维数组索引越界)，或者当前节点不是 '1' (陆地)
2. 确定 DFS 起始节点: 参数使用二维数组表示图的邻接表，那么就从数组第一个元素开始 `grid [0][0]`
3. 确定单次访问节点: 当前节点 上下左右 4 个方向所有为 '1' (陆地) 的节点 (这样就可以连成一片，形成一个小岛)，然后递归，单个节点访问之后，将值标记为 '0', 避免重复访问
4. 状态变量如何更新: 以当前节点开始，完成一轮 DFS 过程，岛屿数量 + 1

```go
func numIslands(grid [][]byte) int {
	var (
		dx             = []int{0, 1, -1, 0}
		dy             = []int{1, 0, 0, -1}
		rowLen, colLen = len(grid), len(grid[0])
		dfs            func(int, int)
		ans            int
	)
	
	dfs = func(row, col int) {
		var x, y int
		grid[row][col] = '0'
		for i := 0; i < 4; i++ {
			x, y = row+dx[i], col+dy[i]
			if x >= 0 && x < rowLen && y >= 0 && y < colLen && grid[x][y] == '1' {
				dfs(x, y)
			}
		}
	}
	
	for i := range grid {
		for j := range grid[i] {
			if grid[i][j] == '1' {
				dfs(i, j)
				ans++
			}
		}
	}
	return ans
}
```