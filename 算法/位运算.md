# 1. 统计位 1 的个数

##  [191. 位1的个数 ](https://leetcode.cn/problems/number-of-1-bits/description/)
编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中设置位的个数（也被称为[汉明重量](https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F)）。
> **输入：**n = 11
**输出：**3
**解释：**输入的二进制串 `**1011** 中，共有 3 个设置位。`

> **输入：**n = 128
**输出：**1
**解释：**输入的二进制串 **10000000** 中，共有 1 个设置位。

## **模板**

![](picture/c9856645106fdf312326e974b4bdc383_MD5.jpeg)

```go
func onesCount(num uint32) int {
    // 累计器初始值设置为 0
    cnt := 0

    for num != 0 {
        // 每次去掉二进制表示中最右边的 1
        // 过程可以参考上面的示例图
        num &= num - 1

        // 增加累计结果
        cnt++
    }

    // 返回累计结果
    return cnt
}
```

##  [338. 比特位计数 ](https://leetcode.cn/problems/counting-bits/description/)

给你一个整数 `n` ，对于 `0 <= i <= n` 中的每个 `i` ，计算其二进制表示中 **`1` 的个数** ，返回一个长度为 `n + 1` 的数组 `ans` 作为答案。

> **输入：**n = 2
**输出：**[0,1,1]
**解释：**
0 --> 0
1 --> 1
2 --> 10

> **输入：**n = 5
**输出：**[0,1,1,2,1,2]
**解释：**
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101

### 解 1

```go
func countBits(n int) []int {
    res: = make([]int,num+1)  
    for i := 0; i <= num; i++{  
        // 逐个计算数字的二进制表示中 1 的个数  
        res[i] = onesCount(i)  
    }  
  
    return res
}
```


### 解 2

```go
func countBits(n int) []int { 
	bits := make([]int, n+1) 
	for i := 1; i <= n; i++ {
		// i & i-1 去掉一个1，因此第i个数的1的个数为 bits[i&i-1] +1
		bits[i] = bits[i&(i-1)] + 1 
	} 
	return bits 
}
```

## [762. 二进制表示中质数个计算置位](https://leetcode.cn/problems/prime-number-of-set-bits-in-binary-representation/description/)

给你两个整数 `left` 和 `right` ，在闭区间 `[left, right]` 范围内，统计并返回 **计算置位位数为质数** 的整数个数。

**计算置位位数** 就是二进制表示中 `1` 的个数。

> **输入：**left = 6, right = 10
**输出：**4
**解释：**
6 -> 110 (2 个计算置位，2 是质数)
7 -> 111 (3 个计算置位，3 是质数)
9 -> 1001 (2 个计算置位，2 是质数)
10-> 1010 (2 个计算置位，2 是质数)
共计 4 个计算置位为质数的数字。

解题思路：和刚才的题目类似，只是多加了一层判断是否为质数的处理逻辑，直接套用模板加循环即可。

```go
func isPrime(x int) bool { 
	if x < 2 { 
		return false 
	} 
	for i := 2; i*i <= x; i++ { 
		if x%i == 0 { 
			return false 
		} 
	} 
	return true 
}

func countPrimeSetBits(left, right int) (ans int) { 
	for x := left; x <= right; x++ { 
		if isPrime(onesCount(x)) { 
			ans++ 
		} 
	} 
	return 
}
```

## [面试题 05.06. 整数转换](https://leetcode.cn/problems/convert-integer-lcci/description/)

整数转换。编写一个函数，确定需要改变几个位才能将整数A转成整数B。

> **输入**：A = 29 （或者0b11101）, B = 15（或者0b01111）
 **输出**：2

解题思路：A 需要转换多少位才可以变为 B, 换个角度也就是计算 A 和 B 的异或结果中，有多少位为 1 的个数，依然直接套用模板即可。

```go
func convertInteger(A int, B int) int {
    return onesCount(uint32(A ^ B))
}
```

## [2220. 转换数字的最少位翻转次数](https://leetcode.cn/problems/minimum-bit-flips-to-convert-number/description/)

同上题

# 2. 出现 N 次的数字

