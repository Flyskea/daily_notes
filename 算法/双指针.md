# 基础

## 1. 快慢指针

最经典的双指针使用场景
一般情况下，快慢指针的固定命名:

```
快指针:  fast慢指针:  slow
```

![图片](../picture/1598d50fc13a6845ad55abbce14c0f38_MD5.webp)

快慢指针示例

## 2. 左右指针

通常用于解决数组或字符串问题，其中:

- 左指针通常指向数组下标 0 ，字符串的开始位置
    
- 右指针通常指向数组下标 N-1 (其中 N 为数组长度)，字符串的结束位置
    

一般情况下，左右指针的固定命名:

```
左指针:  left右指针:  right
```

![图片](../picture/6b67a37a9d2d8c726f74cef45e3cfd0c_MD5.webp)

左右指针示例

## 3. 无序指针

如果两个指针没有任何语义和逻辑顺序，只是用于指向不同的地址，也可以直接简单命名。

例如在合并两个有序链表这道题中，可以使用两个无序指针分别指向链表 1 和链表 2:

```
指针 1: p1指针 2: p2
```

![图片](../picture/ca9fbd5051e68eec17955a7da578f9c9_MD5.webp)

无序指针示例

## 4. 头尾指针

这种场景中，两个指针每次移动的位置不一样，可能移动也可能原地不动 (所以单纯应用角度分析的话，**头尾双指针属于快慢双指针的子集**)，例如使用数组使用的环形队列数据结构。

一般情况下，头尾指针的固定命名:

```
头指针 1: head尾指针 2: tail
```

![图片](../picture/cd87cc94df9e01c7c6e2f845b61c189c_MD5.webp)

# 头尾双指针

头尾双指针的典型使用场景是：

- **头指针** 作为数组/字符串的遍历索引，从起始位置遍历到结束位置
    
- **尾指针** 作为条件指针，每次移动 0 个位置或 1 个位置，并在满足题目逻辑条件时更新返回值，或者自身作为最终返回值

## [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

给你一个 **非严格递增排列** 的数组 `nums` ，请你 **[原地](http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。

**示例 1：**

> **输入：** nums = [1,1,2]
> **输出：** 2, nums = [1,2,_]
> **解释：** 函数应该返回新的长度 **`2`** ，并且原数组 _nums_ 的前两个元素被修改为 **`1`**, **`2`** `。` 不需要考虑数组中超出新长度后面的元素。

解题思路：

**使用两个指针,**`tail` 指针指向最后一个不重复元素的位置。`head` 指针用于遍历数组。
- 如果 `head` 指针指向的元素与 `tail` 指针指向的元素不同，则 `tail` 前进一步，并将 `head` 指向的元素复制到 `tail` 位置。
- `tail + 1` 即为去重后数组的长度。

```go
func removeDuplicates(nums []int) int {
    tail := 0
    
    for head := 1; head < len(nums); head++ {
        if nums[head] != nums[tail] {
            tail++
            nums[tail] = nums[head]
        }
    }

    return tail + 1
}
```

## [27. 移除元素](https://leetcode.cn/problems/remove-element/description/)

给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)** 移除所有数值等于 `val` 的元素。元素的顺序可能发生改变。然后返回 `nums` 中与 `val` 不同的元素的数量。

**示例 1：**

> **输入：** nums = [3,2,2,3], val = 3
> **输出：** 2, nums = [2,2,_,_]
> **解释：** 你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。
> 你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。

解题思路：

使用两个指针,`tail` 指向当前处理的最后一个不等于 `val` 的元素位置。`head` 指针用于遍历数组。
- 如果 `head` 指针指向的元素不等于 `val`，将 `head` 指针指向的元素复制到 `tail` 指针位置，`tail` 前进一步。
- `tail` 即为删除后的数组长度。

```go
func removeElement(nums []int, val int) int {
    tail := 0

    for head := range nums {
        if nums[head] != val {
            nums[tail] = nums[head]
            tail++
        }
    }

    return tail
}
```

## [392. 判断子序列](https://leetcode.cn/problems/is-subsequence/description/)

给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`"ace"` 是 `"abcde"` 的一个子序列，而 `"aec"` 不是）。

**示例 1：**

> **输入：** s = "abc", t = "ahbgdc"
> **输出：** true

**示例 2：**

> **输入：** s = "axc", t = "ahbgdc"
> **输出：** false

解题思路：

定义头指针为 `head`, 尾指针为 `tail`。
- ``head`` 作为遍历字符串 `t` 的索引，每次循环都加 1
- `tail` 作为更新 **子字符串 s 中当前需要检测字符**的索引，如果 `s[tail] == t[head]`，tail 加 1。
- 如果 `len(s) == tail` 说明匹配成功返回 `true`

```go
func isSubsequence(s string, t string) bool {
	// 如果子字符串为空，就必然属于子集合
	// (Tips: 空字符串也属于子集合之一)
	sLen, tLen := len(s), len(t)
	tail, head := 0, 0

	for tail < sLen && head < tLen {
		if s[tail] == t[head] {
			tail++
		}
		head++
	}

	return tail == sLen
}
```