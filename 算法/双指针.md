# 基础

## 1. 快慢指针

最经典的双指针使用场景
一般情况下，快慢指针的固定命名:

```
快指针:  fast慢指针:  slow
```

![图片](../picture/1598d50fc13a6845ad55abbce14c0f38_MD5.webp)

快慢指针示例

## 2. 左右指针

通常用于解决数组或字符串问题，其中:

- 左指针通常指向数组下标 0 ，字符串的开始位置
    
- 右指针通常指向数组下标 N-1 (其中 N 为数组长度)，字符串的结束位置
    

一般情况下，左右指针的固定命名:

```
左指针:  left右指针:  right
```

![图片](../picture/6b67a37a9d2d8c726f74cef45e3cfd0c_MD5.webp)

左右指针示例

## 3. 无序指针

如果两个指针没有任何语义和逻辑顺序，只是用于指向不同的地址，也可以直接简单命名。

例如在合并两个有序链表这道题中，可以使用两个无序指针分别指向链表 1 和链表 2:

```
指针 1: p1指针 2: p2
```

![图片](../picture/ca9fbd5051e68eec17955a7da578f9c9_MD5.webp)

无序指针示例

## 4. 头尾指针

这种场景中，两个指针每次移动的位置不一样，可能移动也可能原地不动 (所以单纯应用角度分析的话，**头尾双指针属于快慢双指针的子集**)，例如使用数组使用的环形队列数据结构。

一般情况下，头尾指针的固定命名:

```
头指针 1: head尾指针 2: tail
```

![图片](../picture/cd87cc94df9e01c7c6e2f845b61c189c_MD5.webp)

# 头尾双指针

头尾双指针的典型使用场景是：

- **头指针** 作为数组/字符串的遍历索引，从起始位置遍历到结束位置
    
- **尾指针** 作为条件指针，每次移动 0 个位置或 1 个位置，并在满足题目逻辑条件时更新返回值，或者自身作为最终返回值

## [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

给你一个 **非严格递增排列** 的数组 `nums` ，请你 **[原地](http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。

**示例 1：**

> **输入：** nums = [1,1,2]
> **输出：** 2, nums = [1,2,_]
> **解释：** 函数应该返回新的长度 **`2`** ，并且原数组 _nums_ 的前两个元素被修改为 **`1`**, **`2`** `。` 不需要考虑数组中超出新长度后面的元素。

解题思路：

**使用两个指针,**`tail` 指针指向最后一个不重复元素的位置。`head` 指针用于遍历数组。
- 如果 `head` 指针指向的元素与 `tail` 指针指向的元素不同，则 `tail` 前进一步，并将 `head` 指向的元素复制到 `tail` 位置。
- `tail + 1` 即为去重后数组的长度。

```go
func removeDuplicates(nums []int) int {
    tail := 0
    
    for head := 1; head < len(nums); head++ {
        if nums[head] != nums[tail] {
            tail++
            nums[tail] = nums[head]
        }
    }

    return tail + 1
}
```