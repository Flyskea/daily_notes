要实现水平扩展，重要的是要高效均匀地将请求/数据分布到各个服务器上。一致性哈希是实现该目标一种常用的技术。但首先，让我们深入了解这个问题。

## 再哈希问题 (rehashing problem)

如果你有 n 个缓存服务器，一种常用的负载均衡方法是使用以下哈希方法：
serverIndex = hash(key) % N，其中 N 是服务器池的大小。

让我们通过一个示例来说明它是如何工作的。如表5-1所示，我们有4个服务器和8个字符串键及其哈希值。

表 5-1

| key  	| hash     	| hash % 4 	|
|------	|----------	|----------	|
| key0 	| 18358617 	| 1        	|
| key1 	| 26143584 	| 0        	|
| key2 	| 18131146 	| 2        	|
| key3 	| 35863496 	| 0        	|
| key4 	| 34085809 	| 1        	|
| key5 	| 27581703 	| 3        	|
| key6 	| 38164978 	| 2        	|
| key7 	| 22530351 	| 3        	|

  
为了获取存储有某个键的服务器，我们执行模运算 f(key) % 4。例如，hash(key0) % 4 = 1 表示客户端必须联系服务器 1 来获取缓存数据。图5-1展示了基于表5-1的键分布情况。

![the distribution of keys](../picture/Pasted%20image%2020230612104242.png)

这种方法在服务器池的大小固定且数据分布均匀时效果良好。然而，当添加新的服务器或移除现有的服务器时，就会出现问题。例如，如果服务器1下线，服务器池的大小变为3。使用相同的哈希函数，我们得到相同的哈希值。但是，应用模运算会给出不同的服务器索引，因为服务器的数量减少了1。通过应用哈希值 % 3，我们得到如表5-2所示的结果：

表 5 - 2

| key  	| hash     	| hash % 4 	|
|------	|----------	|----------	|
| key 0 	| 18358617 	| 0        	|
| key 1 	| 26143584 	| 0        	|
| key 2 	| 18131146 	| 1        	|
| key 3 	| 35863496 	| 2        	|
| key 4 	| 34085809 	| 1        	|
| key 5 	| 27581703 	| 0        	|
| key 6 	| 38164978 	| 1        	|
| key 7 	| 22530351 	| 0        	|

图5-2展示了基于表5-2的键的新分布情况。

![](../picture/Pasted%20image%2020230612105010.png)

  
正如图5-2所示，大多数键都被重新分布，不仅仅是最初存储在离线服务器（服务器1）中的键。这意味着当服务器1下线时，大多数缓存客户端将连接到错误的服务器来获取数据。这会导致缓存未命中的风暴。一致性哈希是一种有效的技术，用于缓解这个问题。
 
## 一致性哈希 (consistent hashing)

引用自维基百科："一致性哈希是一种特殊的哈希方法，当调整哈希表的大小并使用一致性哈希时，平均只需要重新映射 k/n 个键，其中 k 是键的数量，n 是槽位的数量。相比之下，在大多数传统哈希表中，更改数组槽位的数量会导致几乎所有的键都需要重新映射[1]。"

### 哈希空间和哈希环

现在我们了解了一致性哈希的定义，让我们看看它是如何工作的。假设我们使用 SHA-1作为哈希函数 f，并且哈希函数的输出范围是：x0、x1、x2、x3、…、xn。在密码学中，SHA-1的哈希空间范围是从0到2^160 - 1。这意味着 x0 对应于0，xn 对应于2^160 - 1，而中间的所有其他哈希值都介于0和2^160 - 1之间。图5-3展示了哈希空间。

![](../picture/Pasted%20image%2020230612105314.png)

通过连接两端，我们得到一个哈希环，如图5-4所示：

![](../picture/Pasted%20image%2020230612105335.png)

### 哈希服务器 

使用相同的哈希函数 f，我们根据服务器的 IP 或名称将服务器映射到哈希环上。图5-5显示了4个服务器在哈希环上的映射。

![](../picture/Pasted%20image%2020230612105500.png)

  
### 哈希键 

值得一提的是，这里使用的哈希函数与“再哈希问题”中的函数不同，并且没有模运算。如图5-6所示，4个缓存键（key0、key1、key2和 key3）被哈希到哈希环上。

![](../picture/Pasted%20image%2020230612105659.png)

### 寻找服务器

要确定一个键存储在哪个服务器上，我们从哈希环上的键位置开始顺时针查找，直到找到一个服务器。图5-7解释了这个过程。按顺时针方向，key0 存储在服务器 0 上；key1 存储在服务器 1 上；key2 存储在服务器 2 上；key3 存储在服务器 3 上。

### 添加一个服务器

根据上述逻辑，添加一个新的服务器只需要重新分配一小部分的键。

在图5-8中，添加了一个新的服务器4后，只有 key0需要重新分配。k1、k2和 k3仍然存储在相同的服务器上。让我们仔细看一下这个逻辑。在添加服务器4之前，key0存储在服务器0上。现在，key0将存储在服务器4上，因为从 key0在环上的位置顺时针前进，服务器4是它遇到的第一个服务器。根据一致性哈希算法，其他键不会被重新分配。

### 移除一个服务器

当移除一个服务器时，使用一致性哈希算法只需要重新分配一小部分的键。

在图5-9中，当移除服务器1时，只有 key1需要重新映射到服务器2上。其余的键不受影响。

![](../picture/Pasted%20image%2020230612110034.png)

### 基本方法中的两个问题

一致性哈希算法由MIT的Karger等人引入[1]。基本步骤如下：

- 使用均匀分布的哈希函数将服务器和键映射到环上。
- 要确定一个键被映射到哪个服务器上，从键的位置开始顺时针遍历，直到找到环上的第一个服务器。

该方法存在两个问题：

首先，考虑到服务器可能被添加或移除，很难保持环上所有服务器的分区大小相同。一个分区是相邻服务器之间的哈希空间。可能出现分配给每个服务器的分区在环上的大小非常小或相对较大的情况。在图5-10中，如果移除了 s1，s2的分区（用双向箭头标记）将比 s0和 s3的分区大一倍。

![](../picture/Pasted%20image%2020230612110207.png)

其次，在环上可能存在非均匀的键分布。例如，如果服务器被映射到图5-11中列出的位置，大部分键将存储在服务器2上。然而，服务器1和服务器3没有任何数据。

![](../picture/Pasted%20image%2020230612110255.png)

一种被称为虚拟节点或复制的技术用以解决该问题。

### 虚拟节点

虚拟节点指的是真实节点，在环上，每个服务器由多个虚拟节点表示。在图5-12中，服务器0和服务器1都有3个虚拟节点。这里的3是任意选择的，在实际的系统中，虚拟节点的数量通常更多。我们使用 s0_0、s0_1和 s0_2来表示环上的服务器0，而 s1_0、s1_1和 s1_2则表示环上的服务器1。通过虚拟节点，每个服务器负责多个分区。以标签 s0表示的分区（边）由服务器0管理，而以标签 s1表示的分区则由服务器1管理。

![](../picture/Pasted%20image%2020230612110418.png)

为了确定一个键存储在哪个服务器上，我们从键的位置开始顺时针遍历环，并找到遇到的第一个虚拟节点。在图5-13中，为了确定键 k0存储在哪个服务器上，我们从 k0的位置开始顺时针遍历，找到虚拟节点 s1_1，它对应着服务器1。

![](../picture/Pasted%20image%2020230612110459.png)

随着虚拟节点数量的增加，键的分布变得更加均衡。这是因为随着虚拟节点的增加，标准差变小，从而实现了数据的均衡分布。标准差用于衡量数据的离散程度。在线研究[2]进行的实验结果显示，使用一两百个虚拟节点时，标准差在均值的5%（200个虚拟节点）到10%（100个虚拟节点）之间。增加虚拟节点的数量将使标准差变小。然而，增加虚拟节点会需要更多的空间来存储关于虚拟节点的数据。这是一个权衡，我们可以调整虚拟节点的数量以适应系统的需求。

### 找到受影响的键

当添加或移除一个服务器时，需要重新分配一部分数据。我们如何找到受影响的范围以重新分配键呢？在图5-14中，服务器4被添加到环上。受影响的范围从 s4（新添加的节点）开始，逆时针沿着环移动，直到找到一个服务器（s3）。因此，位于 s3和 s4之间的键需要重新分配给 s4。

![](../picture/Pasted%20image%2020230612110701.png)

当移除一个服务器（s1），如图5-15所示，受影响的范围从 s1（被移除的节点）开始，逆时针沿着环移动，直到找到一个服务器（s0）。因此，位于 s0和 s1之间的键必须重新分配给 s2。

![](../picture/Pasted%20image%2020230612110812.png)

## 总结

在本章中，我们对一致性哈希进行了深入讨论，包括为什么需要它以及它是如何工作的。一致性哈希的好处包括：

- 当添加或移除服务器时，最小化需要重新分配的键。
- 由于数据更均匀地分布，容易实现水平扩展。
- 缓解热点键问题。对特定分片的过度访问可能导致服务器负载过重。想象一下，Katy Perry、Justin Bieber和Lady Gaga的数据都在同一个分片上。一致性哈希通过更均匀地分布数据来帮助缓解这个问题。

一致性哈希在现实世界的许多系统中被广泛应用，包括一些著名的系统：

- Amazon Dynamo数据库的分区组件 [3]
- Apache Cassandra中的集群数据分区 [4]
- Discord聊天应用 [5]
- Akamai内容分发网络 [6]
- Maglev网络负载均衡器 [7]

恭喜你走到了这一步！现在给自己一个鼓励的拍拍背，干得好！