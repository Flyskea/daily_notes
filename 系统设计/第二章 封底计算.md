封底计算，英文为back-of-the-envelope calculations (BotEC)，这个术语由物理学家恩里科·费米创造，指用简单到可以在手边随便的什么小纸片（比如信封的背面上）进行的计算，对复杂的方程作同一数量级内的近似求解。

> 在系统设计面试中，有时会要求您使用封底计算来评估系统容量或性能需求。据谷歌高级研究员杰夫·迪恩（Jeff Dean）称，“封底计算将心中模拟实验和常见性能数字结合在一起，之后做出的估计。用这种方式来获取对系统设计良好的直觉。”[1](http://highscalability.com/blog/2011/1/26/google-pro-tip-use-back-of-the-envelopecalculations-to-choo.html)。

您需要对可伸缩性基础有很好的了解，才能有效地执行封底计算。应该充分理解以下概念：2的幂[2](https://github.com/donnemartin/system-design-primer)（power of two）、常见的时延数和可用性数量。

## 2的幂

在处理分布式系统时，数据量可能会变得巨大，但计算是基础的。为了获得正确的计算结果，可以使用2的幂去了解数据量单位。Byte是由8bit组成的序列。ASCII字符使用一个byte的内存（8位）。下表解释了数据量单位（表2-1）。

 **表 2 - 1**
>
> | 幂次 	| 大致估计值    	| 全名       	| 缩写名 	|
> |------	|---------------	|------------	|--------	|
> | 10   	| 1 Thousand    	| 1 Kilobyte 	| 1 KB   	|
> | 20   	| 1 Milion      	| 1 Megabyte 	| 1 MB   	|
> | 30   	| 1 Billion     	| 1 Gigabyte 	| 1 GB   	|
> | 40   	| 1 Trilion     	| 1 Terabyte 	| 1 TB   	|
> | 50   	| 1 Quadrillion 	| 1 Petabyte 	| 1 PB   	|

## 程序员必须知道的时延数量
谷歌的博士揭示了2010年典型计算机操作的时间长度[1](http://highscalability.com/blog/2011/1/26/google-pro-tip-use-back-of-the-envelopecalculations-to-choo.html)(如表2-2所示)。随着计算机变得更快、更强大，一些数字已经过时。然而，这些数字仍然能够让我们了解不同计算机操作的快速性和缓慢性。

表 2 - 2

> | 操作名称                               	| 时间       	|
> |----------------------------------------	|------------	|
> | L1 cache 引用                          	| 0.5 ns     	|
> | 分支预测失误                           	| 5ns        	|
> | L2 cache 引用                          	| 7 ns       	|
> | Mutex lock/unlock                      	| 100 ns     	|
> | 主内存引用                             	| 100 ns     	|
> | 使用Zippy压缩1K Byte                   	| 10 μs      	|
> | 通过1 Gbps网络发送2K字节               	| 20 μs      	|
> | 从内存中按顺序读取1 MB                 	| 250 μs     	|
> | 同一数据中心内往返                     	| 500 μs     	|
> | 磁盘搜索                               	| 10 ms      	|
> | 从网络中按顺序读取1MB                  	| 10ms       	|
> | 从磁盘按顺序读取1 MB                   	| 30 ms      	|
> | 发送数据包CA（加利福尼亚州）->荷兰->CA 	| 150,000,00 	|

【注】:

- ns=纳秒，μs=微秒，ms=毫秒
- ns=10^-9秒
- 1μs=10^-6秒=1000 ns
- 1 ms=10^-3秒=1000μs=1000000 ns

谷歌软件工程师开发了一个工具来可视化Dean博士的数字。该工具还考虑了时间因素。图2-1可视化显示了2020年的时延数（图来源：参考资料[3](https://colin-scott.github.io/personal_website/research/interactive_latency.html)）
![[Pasted image 20230527203235.png]]

通过分析图2-1中的数字，我们得出以下结论：

- 内存很快，但磁盘很慢。
- 尽可能避免磁盘搜索。
- 简单的压缩算法速度快
- 如果可能，在通过互联网发送数据之前压缩数据。
- 数据中心通常位于不同的区域，在它们之间发送数据需要时间。

## 可用性（Availability）
高可用性是指系统能够在理想的长时间内持续运作的能力。高可用性是以百分比来衡量的，100%意味着服务没有宕机时间。大多数服务可用性在99%到100%之间。

服务水平协议（SLA）是服务提供商常用的术语。这是服务提供商和客户之间的协议，该协议正式定义了您的服务将提供的正常运行时间级别。云提供商亚马逊[[4]](https://aws.amazon.com/compute/sla/)、谷歌[5](https://cloud.google.com/compute/sla)和微软[[6]](https://azure.microsoft.com/enus/support/legal/sla/summary/)将服务水平协议（SLA）设定为99.9%或以上。可用性通常以9来衡量，9越多越好。如表2-3所示，9的数量与系统预计宕机时间相关。

表 2 - 3

> | 可用性   | 平均每天宕机时间 | 平均每年宕机时间 |
> |----------|------------------|------------------|
> | 99%      | 14.4 分钟        | 3.65天           |
> | 99.9%    | 1.44 分钟        | 8.77小时         |
> | 99.99%   | 8.64 秒          | 52.6分钟         |
> | 99.999%  | 864毫秒          | 5.26分钟         |
> | 99.9999% | 86.4毫秒         | 31.56秒          |

## 实例：估算twitter的QPS和存储空间
注意以下数字不是twitter真实用户数据，仅仅是一个联系

假设：
> 每月有3亿的活跃用户
> 50%的用户每天使用twitter
> 用户每天平均发送两条推文
> 10%的推文有媒体内容（图片、视频）
> 数据需要存5年

估算:
1）QPS(Query per second)估算：
- DAU（Daily active user,每日活跃用户): 300million * 50% = 150 million
- Tweets QPS = 150 million * 2 tweets/24小时/3600s = ~3500
- QPS峰值 = 2* QPS = ~7000

2）媒体存储内容估算：
- 平均推文大小： 推文Id：65 byte 推文正文：140 bytes 媒体：1MB
- 媒体大小：150million * 2 * 10% = 30TB/天
- 5年的媒体存储： 30TB * 365 * 5 = ~55PB

## 提示
封底估算主要是过程， 解决问题比得到结果更重要，面试者主要考察你的问题解决能力，有以下提示
- 四舍五入和近似值。在面试中很难进行复杂的数学运算。例如，“99987/9.1”的结果是什么？没有必要花费宝贵的时间来解决复杂的数学问题。预计不会有精确性。使用四舍五入的数字和近似值。以上问题可以简化为：“100000/10”
- 写下你的假设：最好写下你的假设，用于之后参考。
- 给数字添加单位。当你写下“5”时，它是指5KB还是5MB？而写下单位有助于消除歧义。
- 常见的信封背面估算：QPS、QPS峰值、存储、缓存、服务器数量等，平时可以做些这方面的联系，以达到熟能生巧。